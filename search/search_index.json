{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CoderDojo Robots \u00b6 Note We are no longer supporting Arduino robots. All of our new CoderDojo and Code Savvy lesson plans are being moved to MicroPython . This repository is used for historical purposes only. Table of Contents \u00b6 Getting Started Instructor's Guide Components Assembly Programming Testing Motor Connections Motor Speed Lab Moving Forward and Backward Motor Direction Lab Turning Sensors Programming with Scratch Extending The Base Robot Adding a Face Glossary Documentation built with mkdocs material and GitHub Pages","title":"CoderDojo Robots"},{"location":"#coderdojo-robots","text":"Note We are no longer supporting Arduino robots. All of our new CoderDojo and Code Savvy lesson plans are being moved to MicroPython . This repository is used for historical purposes only.","title":"CoderDojo Robots"},{"location":"#table-of-contents","text":"Getting Started Instructor's Guide Components Assembly Programming Testing Motor Connections Motor Speed Lab Moving Forward and Backward Motor Direction Lab Turning Sensors Programming with Scratch Extending The Base Robot Adding a Face Glossary Documentation built with mkdocs material and GitHub Pages","title":"Table of Contents"},{"location":"arduino/","text":"Instructor's Guide \u00b6 Our goal is to teach some of the following computer science concepts: Physical Computing - we teach students how to read sensors, do transformations and control the world around them. Using an IDE - Setup and install the Arduino Integrated Development Environment to edit, compile, debug and upload your programs to an Arduino computer. This includes the tricky process of installing Arduino drivers. Uploading - loading a program from your IDE to an Arduino Parts of a program - Libraries, includes, global variables, Installing libraries - How to find and install Arduino libraries and how to get around problems when the libraries don't work together Preamble - What to put at the top of your Arduino program before you run your setup program The setup() function - The initialization function that gets run only once when your program first starts up The main loop() - The function that keeps running until your program is reset or powers down Variables - How to name locations in your program's memory and how to use them Reading sensor data - how to read the values from the outside world Transforming data - using the map() and constrain() functions to get your variables ready for output The H-Bridge - changing motor direction Transistors and motor controllers - which is right for your project The L293D motor controller - a guide to a simple low cost chip that can control two DC motors Changing motor speed - how to change motor speed using pulse wave modulation (PWM) The motor speed lab - a lab that allows you to change the speed of a motor using a potentiometer and motor controller Motor Direction Lab - a lab that allows you to change the direction of your motor based on the value of a The Ping Sensor - using an ultrasonic sensor to measuring the distance of an obstacle in front of your robot Subroutine Functions - how to package a small chunk of code into reusable components. How to pass parameters into functions. Collision avoidance - driving and turning when you get close to an obstacle Extending your robot - our breadboard has extra space (14 rows of connections) that you can use to extend your robot including adding an infrared remote control, a Bluetooth controller or other displays and sensors Sharing your robot code - using a version control system (git) to share your work","title":"Instructor's Guide"},{"location":"arduino/#instructors-guide","text":"Our goal is to teach some of the following computer science concepts: Physical Computing - we teach students how to read sensors, do transformations and control the world around them. Using an IDE - Setup and install the Arduino Integrated Development Environment to edit, compile, debug and upload your programs to an Arduino computer. This includes the tricky process of installing Arduino drivers. Uploading - loading a program from your IDE to an Arduino Parts of a program - Libraries, includes, global variables, Installing libraries - How to find and install Arduino libraries and how to get around problems when the libraries don't work together Preamble - What to put at the top of your Arduino program before you run your setup program The setup() function - The initialization function that gets run only once when your program first starts up The main loop() - The function that keeps running until your program is reset or powers down Variables - How to name locations in your program's memory and how to use them Reading sensor data - how to read the values from the outside world Transforming data - using the map() and constrain() functions to get your variables ready for output The H-Bridge - changing motor direction Transistors and motor controllers - which is right for your project The L293D motor controller - a guide to a simple low cost chip that can control two DC motors Changing motor speed - how to change motor speed using pulse wave modulation (PWM) The motor speed lab - a lab that allows you to change the speed of a motor using a potentiometer and motor controller Motor Direction Lab - a lab that allows you to change the direction of your motor based on the value of a The Ping Sensor - using an ultrasonic sensor to measuring the distance of an obstacle in front of your robot Subroutine Functions - how to package a small chunk of code into reusable components. How to pass parameters into functions. Collision avoidance - driving and turning when you get close to an obstacle Extending your robot - our breadboard has extra space (14 rows of connections) that you can use to extend your robot including adding an infrared remote control, a Bluetooth controller or other displays and sensors Sharing your robot code - using a version control system (git) to share your work","title":"Instructor's Guide"},{"location":"getting-started/","text":"Getting Started \u00b6 So - you want to build your own Robot that you can program! Great idea! Before you begin lets talk about a few key things to keep you on track and keep you from getting frustrated. This book uses the CoderDojo philosophy. The word \"Dojo\" is Japanese term for \"a training place\" - a safe place you can go to learn. This means that you should spend about two to three hours every other week with someone that can mentor you and help you solve problems. Building robots and writing programs can be frustrating for you and your parents if you run into problems. The best way to overcome these problems is to ask for help. An experienced mentor will not just solve a problem for you, but teach you ways you can figure out the problems on your own. Knowing how to debug is part of building great robots! Finding your Dojo is sometimes not an easy task. You can use a search engine like Google to search for a local CoderDojo chapter or you can ask your teachers if there are science clubs or volunteers that might help you. Whatever you do, don't give up when you hit a problem. Take a break and realize that all great engineers need to be good at overcoming problems. And never be afraid to ask for help. Our kit requires a bit of soldering. There are six connections (for motor connections and two switch connections). If you don't know how to solder try to find someone who can help you solder the wires or can solder the wires for you. If you want to learn to solder that is great! Just be careful that you don't burn yourself or set your house on fire! Always have an adult present when you fist learn to solder. The motor driver board we recommend has some small screws for tightening down the wires in the header. A 3/32\" flat head screwdriver will be needed. A flat blade eyeglass screwdriver will also work. To program the $2 Arduino Nano we get from China you will require a working CH340D driver on your computer. Despite the popularity of the low cost CH340D serial USB interface chip, the Arduino IDE does not include the driver since it is not a \"genuine\" Arduino device. Some older computers many not work with the CH340D driver. For details search for \"Arduino Nano CH340D driver\" and your operating system name. If you are unsure your computer supports this driver you may have to purchase an alternate version of the Arduino Nano that has a genuine branded chip. These versions include the FTDI serial interface chip that has drivers included in the Arduino IDE. The price on the Arduino site is $22+shipping. You can see why the ones from China are preferred!","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"So - you want to build your own Robot that you can program! Great idea! Before you begin lets talk about a few key things to keep you on track and keep you from getting frustrated. This book uses the CoderDojo philosophy. The word \"Dojo\" is Japanese term for \"a training place\" - a safe place you can go to learn. This means that you should spend about two to three hours every other week with someone that can mentor you and help you solve problems. Building robots and writing programs can be frustrating for you and your parents if you run into problems. The best way to overcome these problems is to ask for help. An experienced mentor will not just solve a problem for you, but teach you ways you can figure out the problems on your own. Knowing how to debug is part of building great robots! Finding your Dojo is sometimes not an easy task. You can use a search engine like Google to search for a local CoderDojo chapter or you can ask your teachers if there are science clubs or volunteers that might help you. Whatever you do, don't give up when you hit a problem. Take a break and realize that all great engineers need to be good at overcoming problems. And never be afraid to ask for help. Our kit requires a bit of soldering. There are six connections (for motor connections and two switch connections). If you don't know how to solder try to find someone who can help you solder the wires or can solder the wires for you. If you want to learn to solder that is great! Just be careful that you don't burn yourself or set your house on fire! Always have an adult present when you fist learn to solder. The motor driver board we recommend has some small screws for tightening down the wires in the header. A 3/32\" flat head screwdriver will be needed. A flat blade eyeglass screwdriver will also work. To program the $2 Arduino Nano we get from China you will require a working CH340D driver on your computer. Despite the popularity of the low cost CH340D serial USB interface chip, the Arduino IDE does not include the driver since it is not a \"genuine\" Arduino device. Some older computers many not work with the CH340D driver. For details search for \"Arduino Nano CH340D driver\" and your operating system name. If you are unsure your computer supports this driver you may have to purchase an alternate version of the Arduino Nano that has a genuine branded chip. These versions include the FTDI serial interface chip that has drivers included in the Arduino IDE. The price on the Arduino site is $22+shipping. You can see why the ones from China are preferred!","title":"Getting Started"},{"location":"glossary/","text":"CoderDojo Robot Glossary of Terms \u00b6 ChatGPT Prompt \u00b6 Create a Glossy of Terms for a STEM robotics class. Return the results in alphabetical order using raw markdown format with each term being in a level 4 header. Algorithm \u00b6 An algorithm is a set of instructions or rules that are followed in order to solve a problem or complete a task. In robotics, algorithms are often used to control the robot's movements and to make decisions based on sensor data. Robotics \u00b6 Robotics is a branch of engineering and science that involves the design, construction, operation, and use of robots. It combines aspects of mechanical engineering, electrical engineering, and computer science. Robot \u00b6 A robot is a machine that can be programmed to carry out a series of actions autonomously or semi-autonomously, often controlled by a computer. Actuator \u00b6 An actuator is a device that converts energy into mechanical motion. In robotics, actuators are used to control the movement of the robot's joints, wheels, or other components. Artificial Intelligence \u00b6 Artificial intelligence (AI) is the simulation of human intelligence processes by computer systems. In robotics, AI is used to enable robots to learn, reason, and make decisions based on sensor data and other inputs. Microcontroller \u00b6 A microcontroller is a small computer on a single integrated circuit that is designed to control specific tasks. In robotics, microcontrollers are often used to control the robot's sensors, actuators, and other components. Programming \u00b6 Programming is the process of creating software or code that can be executed by a computer or other electronic device. In robotics, programming is used to control the behavior of the robot and to make it perform specific tasks. Remote Control \u00b6 A remote control is a device used to operate a machine or equipment from a distance. In robotics, a remote control can be used to operate a robot and control its movements and actions. Robot \u00b6 A robot is a machine that can be programmed to carry out a series of actions autonomously or semi-autonomously, often controlled by a computer. Sensor \u00b6 A sensor is a device that detects and responds to some type of input from the physical environment. In robotics, sensors are used to provide information about the robot's surroundings, such as distance, light, temperature, or sound.","title":"CoderDojo Robot Glossary of Terms"},{"location":"glossary/#coderdojo-robot-glossary-of-terms","text":"","title":"CoderDojo Robot Glossary of Terms"},{"location":"glossary/#chatgpt-prompt","text":"Create a Glossy of Terms for a STEM robotics class. Return the results in alphabetical order using raw markdown format with each term being in a level 4 header.","title":"ChatGPT Prompt"},{"location":"glossary/#algorithm","text":"An algorithm is a set of instructions or rules that are followed in order to solve a problem or complete a task. In robotics, algorithms are often used to control the robot's movements and to make decisions based on sensor data.","title":"Algorithm"},{"location":"glossary/#robotics","text":"Robotics is a branch of engineering and science that involves the design, construction, operation, and use of robots. It combines aspects of mechanical engineering, electrical engineering, and computer science.","title":"Robotics"},{"location":"glossary/#robot","text":"A robot is a machine that can be programmed to carry out a series of actions autonomously or semi-autonomously, often controlled by a computer.","title":"Robot"},{"location":"glossary/#actuator","text":"An actuator is a device that converts energy into mechanical motion. In robotics, actuators are used to control the movement of the robot's joints, wheels, or other components.","title":"Actuator"},{"location":"glossary/#artificial-intelligence","text":"Artificial intelligence (AI) is the simulation of human intelligence processes by computer systems. In robotics, AI is used to enable robots to learn, reason, and make decisions based on sensor data and other inputs.","title":"Artificial Intelligence"},{"location":"glossary/#microcontroller","text":"A microcontroller is a small computer on a single integrated circuit that is designed to control specific tasks. In robotics, microcontrollers are often used to control the robot's sensors, actuators, and other components.","title":"Microcontroller"},{"location":"glossary/#programming","text":"Programming is the process of creating software or code that can be executed by a computer or other electronic device. In robotics, programming is used to control the behavior of the robot and to make it perform specific tasks.","title":"Programming"},{"location":"glossary/#remote-control","text":"A remote control is a device used to operate a machine or equipment from a distance. In robotics, a remote control can be used to operate a robot and control its movements and actions.","title":"Remote Control"},{"location":"glossary/#robot_1","text":"A robot is a machine that can be programmed to carry out a series of actions autonomously or semi-autonomously, often controlled by a computer.","title":"Robot"},{"location":"glossary/#sensor","text":"A sensor is a device that detects and responds to some type of input from the physical environment. In robotics, sensors are used to provide information about the robot's surroundings, such as distance, light, temperature, or sound.","title":"Sensor"},{"location":"introduction/","text":"CoderDojo Robots \u00b6 Introduction \u00b6 Welcome! This book is about the use of Arduino robots in teaching computer science topics within the CoderDojo system. Our robots are designed around low-cost components that can be purchased for under $30.00. This guide is designed for both mentors and students. We assume the reader has some experience with Arduino programming including using the Arduino development tools to upload programs into the Arduino. The CoderDojo teaching system is designed around two hour blocks of time where students and mentors come together to learn about topics in software. These robots are specifically designed to teach computer science concepts to students ages 10 to 16 using a hands-on approach guided by mentors. For these robot labs we have decided to build upon the existing Arduino system. Many of our mentors and students have already been exposed to Arduinos and are already comfortable downloading and debugging these programs. Although these robots are used fully assembled in our classrooms, we encourage people to purchase the parts online and build their own robots at home or at school. A full itemized list of parts is provided in the next chapter. Acknowledgements \u00b6 We would like to thank everyone in the CoderDojo program, and the mentors and students that have helped us debug our labs. These efforts would not be possible without the help from Matt Gray and Rebecca Schatz who lead the CoderDojo program in the Twin Cities. We also want to thank others that have provided feedback including Eric Palmer, George Sieverts, Gerd Knops and Doug Thorpe. TODO - get the names of the other mentors.","title":"Introduction"},{"location":"introduction/#coderdojo-robots","text":"","title":"CoderDojo Robots"},{"location":"introduction/#introduction","text":"Welcome! This book is about the use of Arduino robots in teaching computer science topics within the CoderDojo system. Our robots are designed around low-cost components that can be purchased for under $30.00. This guide is designed for both mentors and students. We assume the reader has some experience with Arduino programming including using the Arduino development tools to upload programs into the Arduino. The CoderDojo teaching system is designed around two hour blocks of time where students and mentors come together to learn about topics in software. These robots are specifically designed to teach computer science concepts to students ages 10 to 16 using a hands-on approach guided by mentors. For these robot labs we have decided to build upon the existing Arduino system. Many of our mentors and students have already been exposed to Arduinos and are already comfortable downloading and debugging these programs. Although these robots are used fully assembled in our classrooms, we encourage people to purchase the parts online and build their own robots at home or at school. A full itemized list of parts is provided in the next chapter.","title":"Introduction"},{"location":"introduction/#acknowledgements","text":"We would like to thank everyone in the CoderDojo program, and the mentors and students that have helped us debug our labs. These efforts would not be possible without the help from Matt Gray and Rebecca Schatz who lead the CoderDojo program in the Twin Cities. We also want to thank others that have provided feedback including Eric Palmer, George Sieverts, Gerd Knops and Doug Thorpe. TODO - get the names of the other mentors.","title":"Acknowledgements"},{"location":"summary/","text":"Summary \u00b6 Introduction Getting Started Instructor's Guide Components Assembly Programming Testing Motor Connections Motor Speed Lab Moving Forward and Backward Motor Direction Lab Turning Sensors Programming with Scratch Extending The Base Robot Glossary","title":"Summary"},{"location":"summary/#summary","text":"Introduction Getting Started Instructor's Guide Components Assembly Programming Testing Motor Connections Motor Speed Lab Moving Forward and Backward Motor Direction Lab Turning Sensors Programming with Scratch Extending The Base Robot Glossary","title":"Summary"},{"location":"arduino/00-assembly/","text":"These labs can be used by a wide variety of Arduino kits. The kits should have two DC hobby motors and a motor controller such as the L293C controller that allows you to control a motor with a PWM signal. For many CoderDojo projects we have designed a low cost robot that is described next. $25 Robot Platform for Teaching Programming \u00b6 This robot is built around a standard \"Smart Car\" chassis that you can get on eBay for around $12. It also contains a low-cost motor controller, an Arduino Nano, a ping sensor and a breadboard that allows you to expand the kit in many different ways. The assembly of the robot is documented here","title":"Assembly"},{"location":"arduino/00-assembly/#25-robot-platform-for-teaching-programming","text":"This robot is built around a standard \"Smart Car\" chassis that you can get on eBay for around $12. It also contains a low-cost motor controller, an Arduino Nano, a ping sensor and a breadboard that allows you to expand the kit in many different ways. The assembly of the robot is documented here","title":"$25 Robot Platform for Teaching Programming"},{"location":"arduino/00-components/","text":"We have designed this robot using common components that are low cost and easy to find on-line. You can build your own robot by purchasing parts on sites like eBay or work with a pre-built robot in the CoderDojo sessions. Here is a summary of the parts we use. Part Name Approximate Cost Sample Links Arduino Nano $2.70 e-bay pick-click Robot Chassis with 4AA battery holder $11 e-bay pick-click 1/2 Size 400 point Solderless Breadboard $1.09 e-bay pick-click 170 tie point mini solderless breadboard $1 e-bay L293D Motor Controller $1.54 e-bay e-bay-qty-10 Ultrasonic Ping Sensor HC-SR04 $1 e-bay M-F Dupont Connectors (need 6) $1 e-bay Power Switch $1 e-bay USB 2.0 Cable (A Male to Mini) 50cm $1.70 e-bay 4 AA Batteries $2.00 Costco Total $24.32 There is also a sample collection of parts on e-bay here . Note that the links may point to items that are no longer for sale. However you can find parts with similar descriptions and purchase these parts. You can use our cost estimator Google Docs spreadsheet here . A blog post with sample parts is listed here . Note that the links that this article provides might change, however you should be able to find similar parts using the keywords provided. Now lets step through each of our individual components. Arduino compatible Nano \u00b6 This low-cost microcontoller component is the \"brains\" of our robot. Some of these can be ordered with a USB connector so we can connect them directly to our laptop or desktop computer. We can purchase these for under $5.00. The Nano has eight Analog inputs and 14 Digital input/output pins, six of them can be used to control motor speed with PWM signals. Note that ONLY pings 3, 5, 6, 9, 10, and 11 have PWM output. We will be using Digital Output pins 3,5,6 and 9 in our book. Make sure you read our Getting Started section to properly load the CH340 USB interface. See Arduino Nano Specication for the full specification. 2 DC Motors and Wheels \u00b6 We have decided to use simple Direct Current (DC) motors for our robots. These motors are low cost and work under a variety of voltages from 6 to 12 volts. They come included with our Robot Chassis. L293D Two Motor Controller \u00b6 This part allows us to send signals to each motor to turn the wheels forward and backwards. It has a set of screw terminals to connect the motors and power. This board also has a voltage regulator that will convert voltages from 6 to 12 volts down to 5 volts for controlling our Arduino Nano. This part allow us to drive two motors. See the Wikipedia page for more on how the H-Bridge circuit works. You can use the keywords \"Mini Motor Drive Shield Expansion Board L293D Module For Arduino\" to find your own parts. There are many good on-line tutorials on how these parts work. One example is here . These devices can be found for $1.54 (including shipping) when ordered on e-bay. Ultrasonic Distance Sensor \u00b6 We will use low-cost HC-SR04 ultrasonic distance sensors for our robot. They send out a set of ultrasonic pulse waves out of one speaker and listen for the pulse to return to a microphone. The delay of the return signal corresponds to a distance of an object in front of the robot. They can be purchased for around a dollar on e-bay. We will also use a powerful library to convert the signals into distance measurements. New Ping Solderless Breadboards \u00b6 The robot kit comes with two solderless breadboards, One has 400 connection points and the other smaller board for the sensors has 170 connection points.","title":"Components"},{"location":"arduino/00-components/#arduino-compatible-nano","text":"This low-cost microcontoller component is the \"brains\" of our robot. Some of these can be ordered with a USB connector so we can connect them directly to our laptop or desktop computer. We can purchase these for under $5.00. The Nano has eight Analog inputs and 14 Digital input/output pins, six of them can be used to control motor speed with PWM signals. Note that ONLY pings 3, 5, 6, 9, 10, and 11 have PWM output. We will be using Digital Output pins 3,5,6 and 9 in our book. Make sure you read our Getting Started section to properly load the CH340 USB interface. See Arduino Nano Specication for the full specification.","title":"Arduino compatible Nano"},{"location":"arduino/00-components/#2-dc-motors-and-wheels","text":"We have decided to use simple Direct Current (DC) motors for our robots. These motors are low cost and work under a variety of voltages from 6 to 12 volts. They come included with our Robot Chassis.","title":"2 DC Motors and Wheels"},{"location":"arduino/00-components/#l293d-two-motor-controller","text":"This part allows us to send signals to each motor to turn the wheels forward and backwards. It has a set of screw terminals to connect the motors and power. This board also has a voltage regulator that will convert voltages from 6 to 12 volts down to 5 volts for controlling our Arduino Nano. This part allow us to drive two motors. See the Wikipedia page for more on how the H-Bridge circuit works. You can use the keywords \"Mini Motor Drive Shield Expansion Board L293D Module For Arduino\" to find your own parts. There are many good on-line tutorials on how these parts work. One example is here . These devices can be found for $1.54 (including shipping) when ordered on e-bay.","title":"L293D Two Motor Controller"},{"location":"arduino/00-components/#ultrasonic-distance-sensor","text":"We will use low-cost HC-SR04 ultrasonic distance sensors for our robot. They send out a set of ultrasonic pulse waves out of one speaker and listen for the pulse to return to a microphone. The delay of the return signal corresponds to a distance of an object in front of the robot. They can be purchased for around a dollar on e-bay. We will also use a powerful library to convert the signals into distance measurements. New Ping","title":"Ultrasonic Distance Sensor"},{"location":"arduino/00-components/#solderless-breadboards","text":"The robot kit comes with two solderless breadboards, One has 400 connection points and the other smaller board for the sensors has 170 connection points.","title":"Solderless Breadboards"},{"location":"arduino/00-intro/","text":"Introduction to Basic Arduino Robots \u00b6 In these lessions plans we will learn some basic principals of computer science using a low cost $25 Arduion robot. These lessons are ideal for students that have already mastered basic keyboarding. If you have pre-keyboarding students we suggest using the mBot. Once the students have mastered the labs in this cirriculum they will revieve an Arduino Robots badge. After they complete these labs they are ready to move on to the advanced arduino robot labs that add a $18 OLED dispay. Classroom Setup \u00b6 Our classrooms typically have Arduino robots connected to USB cables that are connected to PCs (Windoes, Mac and Linux). We require that the Arduino and device drivers to be pre installed on the laptops with a person that have adminstrative rights. Some of the CoderDojo programs allow students to bring their own parts in and the students assemble and program them in the classrooms. Other programs provide full-assembled $25 robots. We find students become more engagued when they purchase and assemble their own robots. Order of Labs \u00b6 We start out with the basics of verifying that the student can communicate from their desktop to the Arduino. This ideally should be tested before students arrive. Making sure that the Arduino IDE is installed and all the communications are working can be the most stressful part of these labs. Once the communications are working the fun begins! Basic Motor Labs \u00b6 We start out with basic motor control. We use low-cost motor driver components that are easy to program using Pulse Width Modulation (PWM) output of the Arduinos. The first step is to make the motor turn on and off. Next we make a single motor go forward and backward. Then we work with two motors to go forward and turn. Ping Labs \u00b6 Our robots all have a ultrasonic distance senor on the front. These are also call Ping sensors. They measure the distance in front of a robot and we use them to determine if a robot is about to collide with an object in front of it. Collision Avoidences \u00b6 Once the students know how to control the motors and measure the distance in front of the robot they are ready to create various collision avoidance programs. The first one is simple. It just make the robot turn right if there is an object in front of it. The next once are more sophisticated. They will backup and turn in random directions.","title":"Introduction"},{"location":"arduino/00-intro/#introduction-to-basic-arduino-robots","text":"In these lessions plans we will learn some basic principals of computer science using a low cost $25 Arduion robot. These lessons are ideal for students that have already mastered basic keyboarding. If you have pre-keyboarding students we suggest using the mBot. Once the students have mastered the labs in this cirriculum they will revieve an Arduino Robots badge. After they complete these labs they are ready to move on to the advanced arduino robot labs that add a $18 OLED dispay.","title":"Introduction to Basic Arduino Robots"},{"location":"arduino/00-intro/#classroom-setup","text":"Our classrooms typically have Arduino robots connected to USB cables that are connected to PCs (Windoes, Mac and Linux). We require that the Arduino and device drivers to be pre installed on the laptops with a person that have adminstrative rights. Some of the CoderDojo programs allow students to bring their own parts in and the students assemble and program them in the classrooms. Other programs provide full-assembled $25 robots. We find students become more engagued when they purchase and assemble their own robots.","title":"Classroom Setup"},{"location":"arduino/00-intro/#order-of-labs","text":"We start out with the basics of verifying that the student can communicate from their desktop to the Arduino. This ideally should be tested before students arrive. Making sure that the Arduino IDE is installed and all the communications are working can be the most stressful part of these labs. Once the communications are working the fun begins!","title":"Order of Labs"},{"location":"arduino/00-intro/#basic-motor-labs","text":"We start out with basic motor control. We use low-cost motor driver components that are easy to program using Pulse Width Modulation (PWM) output of the Arduinos. The first step is to make the motor turn on and off. Next we make a single motor go forward and backward. Then we work with two motors to go forward and turn.","title":"Basic Motor Labs"},{"location":"arduino/00-intro/#ping-labs","text":"Our robots all have a ultrasonic distance senor on the front. These are also call Ping sensors. They measure the distance in front of a robot and we use them to determine if a robot is about to collide with an object in front of it.","title":"Ping Labs"},{"location":"arduino/00-intro/#collision-avoidences","text":"Once the students know how to control the motors and measure the distance in front of the robot they are ready to create various collision avoidance programs. The first one is simple. It just make the robot turn right if there is an object in front of it. The next once are more sophisticated. They will backup and turn in random directions.","title":"Collision Avoidences"},{"location":"arduino/01-blink/","text":"Our first step is to verify that our PC or laptop can communicate with the Arduino. To test this first startup the Arduino IDE. You can download it from the internet. Then go to the following menu: File > Examples > 01.Basics > Blink The following program should be visible on your computer screen: 1 2 3 4 5 6 7 8 9 10 void setup () { pinMode ( LED_BUILTIN , OUTPUT ); } void loop () { digitalWrite ( LED_BUILTIN , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( LED_BUILTIN , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } Next, go to the Tools menu and make sure that you have selected the right Arduino processor, the right port and the right version of the bootloader. Note that the Arduino Nano processors we use must be configured to use the old bootloader. No click the right arrow Upload button above the Blink tab. You should see the LEDs on the Arduino briefly blink. After around five seconds you should see the LED on the Arduino flashing on and off every second. You can now change the delay time from one second (1000 milliseconds) to 1/10th of a second (100 milliseconds). The loop function will now look like the following lines: 1 2 3 4 5 6 void loop () { digitalWrite ( LED_BUILTIN , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 100 ); // wait for a second digitalWrite ( LED_BUILTIN , LOW ); // turn the LED off by making the voltage LOW delay ( 100 ); // wait for a second } Now press the Upoad button again. The LED on the Arduino will now be flashing ten times as fast or 10 times per second.","title":"Blink"},{"location":"arduino/01-programming/","text":"We will be using the Arduino IDE to program our robot. This system uses a variation of the C language and the Arduino library to make our motors move. All Arduino programs have a main loop() function that will run continiously. Most programs also have a setup() function that will run only once after the Arduino processor powers up or gets a reset event. Here are some of the common Arduion functions we will use in our robot. Setup \u00b6 pinMode(pin, mode) - used to setup a pin for input and to indicate if the internal pullup resistor is used. Motor Commands \u00b6 analogWrite(pin, power) - used to set the speeds of the motor pins delay(msec) - used to pause the Arduino for a msec milliseconds. delay(1000) will pause for one second Serial Debugging \u00b6 In addion to to these we will use a few functions for displaying numbers to the serial port for debugging. Serial.begin(9600); Serial.println() Serial.print() All of these commands are described on the Arduino web site:","title":"Programming Arduino"},{"location":"arduino/01-programming/#setup","text":"pinMode(pin, mode) - used to setup a pin for input and to indicate if the internal pullup resistor is used.","title":"Setup"},{"location":"arduino/01-programming/#motor-commands","text":"analogWrite(pin, power) - used to set the speeds of the motor pins delay(msec) - used to pause the Arduino for a msec milliseconds. delay(1000) will pause for one second","title":"Motor Commands"},{"location":"arduino/01-programming/#serial-debugging","text":"In addion to to these we will use a few functions for displaying numbers to the serial port for debugging. Serial.begin(9600); Serial.println() Serial.print() All of these commands are described on the Arduino web site:","title":"Serial Debugging"},{"location":"arduino/02-change-motor-speed/","text":"In this lab we will change motor speed using Pulse Wave Modulation (PWM). We will read a value from a potentiometer and change the motor speed as the value changes. To use this lab, connect the ends of a 10K potentiomer to the ground and +5 volts. Then connect the center pin of the pot to the Analog pin 0 (A0) of the Arduino. Then connect a male-female wire from Digital Pin 3 to one of the input pins of the motor control. For this lab you can use any one of the four input pins. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int potPin = A0; // select the input pin for the potentiometer int motorPin = 3; // select the pin for the motor - immutable int potValue; // variable to store the incomming value from the a potentiometer int speed; // The speed of our motor (0=stop, 255=full speed) void setup() { pinMode(potPin, INPUT); pinMode(motorPin, OUTPUT); } void loop() { // read the value from the Potentiometer potValue = analogRead(potPin); // convert the range from 1 to 1023 in to 0 to 255 out speed = map(potValue, 0, 1023, 0, 255); // use PWM to change the speed analogWrite(motorPin, speed); // wait for 1/10 of a second before we continue delay(100); } Note that we can only use one of the 6 PWM pins (3, 5, 6, 9, 10 or 11) to control the speed. The other digital outptus do not support PWM. More to Explore \u00b6 While the program is running, try moving the wire from the digital output pin to any of the other input pins on the motor controller. What happens? Can you make both wheels move? What direction are they moving?","title":"Change Motor Speed"},{"location":"arduino/02-change-motor-speed/#more-to-explore","text":"While the program is running, try moving the wire from the digital output pin to any of the other input pins on the motor controller. What happens? Can you make both wheels move? What direction are they moving?","title":"More to Explore"},{"location":"arduino/03-motor-connection-test/","text":"Testing Motor Connections \u00b6 The following are the tree blocks of code we will use to test if we have our connections are correct. The full test code is here : Keep changing the numbers in the first four lines around until you get the robot wheels to go in the following order: Right forward Right reverse Left forward Left reverse 1 2 3 4 5 6 7 int right_forward = 5 ; int right_reverse = 3 ; int left_forward = 6 ; int left_reverse = 9 ; int delay_time_on = 2000 ; // how long should each wheel turn? int delay_time_off = 1000 ; // delay between tests int delay_end_of_test = 3000 ; // delay between tests Here is our setup code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void setup () { // Turn these pins on for PWM OUTPUT pinMode ( right_forward , OUTPUT ); pinMode ( right_reverse , OUTPUT ); pinMode ( left_forward , OUTPUT ); pinMode ( left_reverse , OUTPUT ); // turn all the motors off digitalWrite ( right_forward , LOW ); digitalWrite ( right_reverse , LOW ); digitalWrite ( left_forward , LOW ); digitalWrite ( left_reverse , LOW ); // for debugging. The output will appear on the serial monitor // To open the serial monitor, click the magnafing glass icon in the upper right corner Serial . begin ( 9600 ); // open the serial port at 9600 bps } Here is the main loop: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void loop () { Serial . println ( \"Right Forward Test\" ); digitalWrite ( right_forward , HIGH ); delay ( delay_time_on ); digitalWrite ( right_forward , LOW ); delay ( delay_time_off ); Serial . println ( \"Right reverse test\" ); digitalWrite ( right_reverse , HIGH ); delay ( delay_time_on ); digitalWrite ( right_reverse , LOW ); delay ( delay_time_off ); Serial . println ( \"Left Forward Test\" ); digitalWrite ( left_forward , HIGH ); delay ( delay_time_on ); digitalWrite ( left_forward , LOW ); delay ( delay_time_off ); Serial . println ( \"Left Reverse Test\" ); digitalWrite ( left_reverse , HIGH ); delay ( delay_time_on ); digitalWrite ( left_reverse , LOW ); delay ( delay_end_of_test ); }","title":"Testing Motor Connections"},{"location":"arduino/03-motor-connection-test/#testing-motor-connections","text":"The following are the tree blocks of code we will use to test if we have our connections are correct. The full test code is here : Keep changing the numbers in the first four lines around until you get the robot wheels to go in the following order: Right forward Right reverse Left forward Left reverse 1 2 3 4 5 6 7 int right_forward = 5 ; int right_reverse = 3 ; int left_forward = 6 ; int left_reverse = 9 ; int delay_time_on = 2000 ; // how long should each wheel turn? int delay_time_off = 1000 ; // delay between tests int delay_end_of_test = 3000 ; // delay between tests Here is our setup code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void setup () { // Turn these pins on for PWM OUTPUT pinMode ( right_forward , OUTPUT ); pinMode ( right_reverse , OUTPUT ); pinMode ( left_forward , OUTPUT ); pinMode ( left_reverse , OUTPUT ); // turn all the motors off digitalWrite ( right_forward , LOW ); digitalWrite ( right_reverse , LOW ); digitalWrite ( left_forward , LOW ); digitalWrite ( left_reverse , LOW ); // for debugging. The output will appear on the serial monitor // To open the serial monitor, click the magnafing glass icon in the upper right corner Serial . begin ( 9600 ); // open the serial port at 9600 bps } Here is the main loop: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void loop () { Serial . println ( \"Right Forward Test\" ); digitalWrite ( right_forward , HIGH ); delay ( delay_time_on ); digitalWrite ( right_forward , LOW ); delay ( delay_time_off ); Serial . println ( \"Right reverse test\" ); digitalWrite ( right_reverse , HIGH ); delay ( delay_time_on ); digitalWrite ( right_reverse , LOW ); delay ( delay_time_off ); Serial . println ( \"Left Forward Test\" ); digitalWrite ( left_forward , HIGH ); delay ( delay_time_on ); digitalWrite ( left_forward , LOW ); delay ( delay_time_off ); Serial . println ( \"Left Reverse Test\" ); digitalWrite ( left_reverse , HIGH ); delay ( delay_time_on ); digitalWrite ( left_reverse , LOW ); delay ( delay_end_of_test ); }","title":"Testing Motor Connections"},{"location":"arduino/03-motor-direction/","text":"In this lab we will hook up our Deek Robot L239D motor controller up to the Arduino Nano. You can get the specification on this board here from the Deek Robot site: http://www.deek-robot.com/productShow.asp?id=17 Here are some key points: * The input voltage can vary from DC4.5-25V * The maximum current is 600mA per motor (1.2A peak). This is well above what 4 AA batteries will use with our DC motors. In practice a full speed motor will draw about 150mA. * There are small red LEDs on the board that indicate if there is a PWM signal being received to the board. You can used this in your debugging. If the motor is not turning, but the red LED is on, it indicates the wires from the board to the motor may not be connected or their is a problem with the motor. If the red LEDs are not lighting up then the may not be a PWM signal getting to the board. * You can enable and disable motors * The chips have overterperatures sensors so the will shut off if they get too hot We will then write a program that will test to see if we got each of the four wires connected from the motor controller to the correct pins on the Arduino. Here is the wiring diagram for our robot: Note that the motors are hooked up to the green \"screw header\" shown at the top of the diagram. * The power from your battery is connected to GND (black wire) and VIN (red wire) * One motor is hooked to the A- and A+ * The other motor is hooked to the B- and B+ The male pins that are at the bottom of the board labeled labeled MCU I/O are on the lower side. These will be labeled IN1, IN2, IN3 and IN4. IN1 and IN2 should get the PWM signals from the Arduino. Only one of the two should get a signal at any time. One will be for forward and one for reverse. Some systems turn both of PWMs on for \"break\", however this uses extra power. Note that the red and black connections here will go to the red and black (or blue) rails of your breadboard. From the rails you will connect power to your Arduino Nano. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* Robot Motors Direction Tests This test makes sure we get all four of the motor dirction pins correct Keep changing these numbers until you get it right directions for each wheel Use the serial monitor to verify which one should be working Note, On the Arduino Nano, only pins 3,5,6,9,10 and 11 have PWM output. You must use these to drive the motors. See https://www.arduino.cc/en/Main/ArduinoBoardNano The convention is to use the first four pins (3,5,6,9) for the motor controls If you use a ribbon connector the order will be 5,3,6 and 9 */ int right_forward = 5; int right_reverse = 3; int left_forward = 6; int left_reverse = 9; int delay_time_on = 2000; // how long should each wheel turn? int delay_time_off = 2000; // delay between tests void setup() { // Turn these pins on for PWM OUTPUT pinMode(right_forward, OUTPUT); pinMode(right_reverse, OUTPUT); pinMode(left_forward, OUTPUT); pinMode(left_reverse, OUTPUT); // turn all the motors off digitalWrite(right_forward, LOW); digitalWrite(right_reverse, LOW); digitalWrite(left_forward, LOW); digitalWrite(left_reverse, LOW); // for debugging. The output will appear on the serial monitor // To open the serial monitor, click the magnafing glass icon in the upper right corner Serial.begin(9600); // open the serial port at 9600 bps } void loop() { Serial.println(\"Right Forward Test\"); digitalWrite(right_forward, HIGH); delay(delay_time_on); digitalWrite(right_forward, LOW); delay(delay_time_off); Serial.println(\"Right reverse test\"); digitalWrite(right_reverse, HIGH); delay(delay_time_on); digitalWrite(right_reverse, LOW); delay(delay_time_off); Serial.println(\"Left Forward Test\"); digitalWrite(left_forward, HIGH); delay(delay_time_on); digitalWrite(left_forward, LOW); delay(delay_time_off); Serial.println(\"Left Reverse Test\"); digitalWrite(left_reverse, HIGH); delay(delay_time_on); digitalWrite(left_reverse, LOW); delay(delay_time_off); } If the the motors are each turning both forward and backward in the order of the test then you know your connections are correct!","title":"L293C Motor Controller"},{"location":"arduino/04-pwm/","text":"In this lab we use the same setup as the prior speed control lab. We use a single potentiometer to control both the speed and direction of a single wheel. This program will be slightly different in that we will send not just one but two PWM signals to our motor. One will be the forward speed and one will be the reverse speed. We will also add an if/then/else statement that will change what PWM signal is sent to the motor controller. All inputs that are in the lower half of the potentiometer range will turn one direction, and the other half will turn the opposite direction. By placing the pot in the middle the wheel will not rotate. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 int potPin = A0 ; // the pin for the potentiometer int motorAForwardPin = 3 ; // Pin to make the motor go forward int motorABackwardPin = 5 ; // Pin to make the motor go backward // one of the inputs on the Motor controller int potValue = 128 ; // variable to store the value coming from the sensor int speedValue = 0 ; // variable to store the value going to the motor void setup () { pinMode ( potPin , INPUT ); pinMode ( motorAForwardPin , OUTPUT ); pinMode ( motorABackwardPin , OUTPUT ); Serial . begin ( 9600 ); } void loop () { potValue = analogRead ( potPin ); // get the value from the Potentiometer from 0 to 1023 Serial . print ( \"pot=\" ); Serial . print ( potValue ); if ( potValue < 512 ) { // we will go backward if the value us under this speedValue = map ( potValue , 0 , 511 , 255 , 0 ); // convert to the right range Serial . print ( \" speed backward=\" ); Serial . println ( speedValue ); analogWrite ( motorABackwardPin , speedValue ); // go back this speed analogWrite ( motorAForwardPin , 0 ); } else { speedValue = map ( potValue , 512 , 1023 , 0 , 255 ); Serial . print ( \" speed forward=\" ); Serial . println ( speedValue ); analogWrite ( motorAForwardPin , speedValue ); // go forward this speed analogWrite ( motorABackwardPin , 0 ); } delay ( 100 ); // sample ever 1/10th of a second } Note that there are now two map statements. One is for the postive direction and one is for the negative direction.","title":"Using PWM Signals"},{"location":"arduino/05-moving-forward-and-backward/","text":"The next step is to make our robot move forward and then backward. To move forward we will send a \"move forward\" signal to both the right and left motors. We will then delay for two seconds. After that we will stop for one second and move backward for two seconds. We can repeat this in our loop. 1 2 3 4 5 6 7 int right_forward = 5 ; int right_reverse = 3 ; int left_forward = 6 ; int left_reverse = 9 ; int forward_time = 2000 ; // how long should we move forward? int stop_time = 1000 ; // how long should we stop between directions? int reverse_time = 2000 ; // how long should we go backward? Here is our setup code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void setup () { // Turn these pins on for PWM OUTPUT pinMode ( right_forward , OUTPUT ); pinMode ( right_reverse , OUTPUT ); pinMode ( left_forward , OUTPUT ); pinMode ( left_reverse , OUTPUT ); // turn all the motors off digitalWrite ( right_forward , LOW ); digitalWrite ( right_reverse , LOW ); digitalWrite ( left_forward , LOW ); digitalWrite ( left_reverse , LOW ); // for debugging. The output will appear on the serial monitor // To open the serial monitor, click the magnafing glass icon in the upper right corner Serial . begin ( 9600 ); // open the serial port at 9600 bps } Here is the main loop: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void loop () { Serial . println ( \"Moving Forward\" ); digitalWrite ( right_forward , HIGH ); digitalWrite ( left_forward , HIGH ); delay ( delay_time_on ); Serial . println ( \"Stopping\" ); digitalWrite ( right_forward , LOW ); digitalWrite ( left_forward , LOW ); delay ( stop_time ); Serial . println ( \"Backing Up\" ); digitalWrite ( right_forward , HIGH ); digitalWrite ( left_forward , HIGH ); delay ( delay_time_off ); Serial . println ( \"Left Forward Test\" ); digitalWrite ( left_forward , HIGH ); delay ( delay_time_on ); digitalWrite ( left_forward , LOW ); delay ( delay_time_off ); Serial . println ( \"Left Reverse Test\" ); digitalWrite ( left_reverse , HIGH ); delay ( delay_time_on ); digitalWrite ( left_reverse , LOW ); delay ( delay_end_of_test ); } Creating functions \u00b6 We can also create a set of functions for each of our drive commands. Functions not only makes it easy to reuse code, but they also make our programs easier for us to read. Here are two C functions for going turning right and moving forward. These two functions are all we will need to create a simple collision avoidance robot. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void turn_right () { Serial . println ( \"turning right\" ); analogWrite ( RIGHT_FORWARD_PIN , LOW ); analogWrite ( RIGHT_REVERSE_PIN , power_turn_level ); analogWrite ( left_forward , power_turn_level ); analogWrite ( left_reverse , LOW ); } void move_forward () { Serial . println ( \"moving forward\" ); analogWrite ( RIGHT_FORWARD_PIN , power_forward_right ); analogWrite ( RIGHT_REVERSE_PIN , LOW ); analogWrite ( left_forward , power_forward_left ); analogWrite ( left_reverse , LOW ); } Advanced Motion Functions \u00b6 Here are four C functions for going forward, reverse and turning right and left. Note that the turning functions (turn right and turn left) both have a function parameter. This is the length of time that the robots will be turning. The longer the delay, the larger an angle the robot will turn. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // turn right for turn_delay_time ms void turn_right ( int turn_delay_time ) { Serial . println ( \"turning right\" ); analogWrite ( RIGHT_FORWARD_PIN , 0 ); analogWrite ( RIGHT_REVERSE_PIN , power_turn_level ); analogWrite ( LEFT_FORWARD_PIN , power_turn_level ); analogWrite ( LEFT_REVERSE_PIN , 0 ); delay ( turn_delay_time ); } void turn_left ( int turn_delay_time ) { Serial . println ( \"turning left\" ); analogWrite ( RIGHT_REVERSE_PIN , 0 ); analogWrite ( RIGHT_FORWARD_PIN , power_turn_level ); analogWrite ( LEFT_REVERSE_PIN , power_turn_level ); analogWrite ( LEFT_FORWARD_PIN , 0 ); delay ( turn_delay_time ); } void move_forward () { Serial . println ( \"moving forward\" ); analogWrite ( RIGHT_FORWARD_PIN , power_forward_right ); analogWrite ( RIGHT_REVERSE_PIN , 0 ); analogWrite ( LEFT_FORWARD_PIN , power_forward_left ); analogWrite ( LEFT_REVERSE_PIN , 0 ); } void move_reverse () { Serial . println ( \"moving reverse\" ); analogWrite ( RIGHT_FORWARD_PIN , 0 ); analogWrite ( RIGHT_REVERSE_PIN , power_forward_right ); analogWrite ( LEFT_FORWARD_PIN , 0 ); analogWrite ( LEFT_REVERSE_PIN , power_forward_left ); }","title":"Moving Forward and Backward"},{"location":"arduino/05-moving-forward-and-backward/#creating-functions","text":"We can also create a set of functions for each of our drive commands. Functions not only makes it easy to reuse code, but they also make our programs easier for us to read. Here are two C functions for going turning right and moving forward. These two functions are all we will need to create a simple collision avoidance robot. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void turn_right () { Serial . println ( \"turning right\" ); analogWrite ( RIGHT_FORWARD_PIN , LOW ); analogWrite ( RIGHT_REVERSE_PIN , power_turn_level ); analogWrite ( left_forward , power_turn_level ); analogWrite ( left_reverse , LOW ); } void move_forward () { Serial . println ( \"moving forward\" ); analogWrite ( RIGHT_FORWARD_PIN , power_forward_right ); analogWrite ( RIGHT_REVERSE_PIN , LOW ); analogWrite ( left_forward , power_forward_left ); analogWrite ( left_reverse , LOW ); }","title":"Creating functions"},{"location":"arduino/05-moving-forward-and-backward/#advanced-motion-functions","text":"Here are four C functions for going forward, reverse and turning right and left. Note that the turning functions (turn right and turn left) both have a function parameter. This is the length of time that the robots will be turning. The longer the delay, the larger an angle the robot will turn. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // turn right for turn_delay_time ms void turn_right ( int turn_delay_time ) { Serial . println ( \"turning right\" ); analogWrite ( RIGHT_FORWARD_PIN , 0 ); analogWrite ( RIGHT_REVERSE_PIN , power_turn_level ); analogWrite ( LEFT_FORWARD_PIN , power_turn_level ); analogWrite ( LEFT_REVERSE_PIN , 0 ); delay ( turn_delay_time ); } void turn_left ( int turn_delay_time ) { Serial . println ( \"turning left\" ); analogWrite ( RIGHT_REVERSE_PIN , 0 ); analogWrite ( RIGHT_FORWARD_PIN , power_turn_level ); analogWrite ( LEFT_REVERSE_PIN , power_turn_level ); analogWrite ( LEFT_FORWARD_PIN , 0 ); delay ( turn_delay_time ); } void move_forward () { Serial . println ( \"moving forward\" ); analogWrite ( RIGHT_FORWARD_PIN , power_forward_right ); analogWrite ( RIGHT_REVERSE_PIN , 0 ); analogWrite ( LEFT_FORWARD_PIN , power_forward_left ); analogWrite ( LEFT_REVERSE_PIN , 0 ); } void move_reverse () { Serial . println ( \"moving reverse\" ); analogWrite ( RIGHT_FORWARD_PIN , 0 ); analogWrite ( RIGHT_REVERSE_PIN , power_forward_right ); analogWrite ( LEFT_FORWARD_PIN , 0 ); analogWrite ( LEFT_REVERSE_PIN , power_forward_left ); }","title":"Advanced Motion Functions"},{"location":"arduino/06-ping-test/","text":"In this lab we will test our ultrasonic distance sensor. We will be using an Arduino library called the NewPing library. To load the NewPing library into your Arduino IDE you can use the following menu: Tools > Manage Libraries... When the manage libraries window opens you will need to search for the NewPing library by typing \"NewPing\" into the seach field in the upper right. Look for the Install menu: You should then be able to run the following program: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // --------------------------------------------------------------------------- // Example NewPing library sketch that does a ping about 20 times per second. // --------------------------------------------------------------------------- #include <NewPing.h> #define TRIGGER_PIN A1 // Arduino pin tied to trigger pin on the ultrasonic sensor. #define ECHO_PIN A0 // Arduino pin tied to echo pin on the ultrasonic sensor. #define MAX_DISTANCE 200 // Maximum distance we want to ping for (in centimeters). Maximum sensor distance is rated at 400-500cm. NewPing sonar ( TRIGGER_PIN , ECHO_PIN , MAX_DISTANCE ); // NewPing setup of pins and maximum distance. void setup () { Serial . begin ( 9600 ); // Open serial monitor at 115200 baud to see ping results. } void loop () { // Wait 50ms between pings (about 20 pings/sec). // 29ms should be the shortest delay between pings. delay ( 50 ); Serial . print ( \"Ping: \" ); Serial . print ( sonar . ping_cm ()); // note if result = 0 it is outside of the range of the sensor Serial . println ( \"cm\" ); } The source code is here:","title":"Ping Test"},{"location":"arduino/08-collision-avoidance/","text":"Our next lab is a collision avoidence program. This program has the robot driving forward unless the robot senses an object in front of it. If the object is less then the threshold for turn (cm_for_turn) then the robot will change the direction of one wheel and turn right. 1 2 3 4 5 if ( dist_in_cm < cm_for_turn ) { turn_right (); } else { move_forward (); } {{site_url}} [Source code] ../../src/collision-avoidance-ping/collision-avoidance-no-leds/collision-avoidance-no-leds/collision-avoidance-no-leds.ino","title":"Collision Avoidance"},{"location":"arduino/glossary/","text":"Glossary of Terms \u00b6 Arduino \u00b6 Arduino is the name of a popular open electronic learning platform based around a set of open standards. Integrated Development Environment (IDE) \u00b6 An integrated development environment (IDE) is a software program used for writing, checking and downloading software into the Arduino. Pulse Wave Modulation (PWM) \u00b6 A way of controlling the speed of a motor or the intensity of a light by changing the amount of time a signal is on. On the Arduino only a subset of output pins can be used to send PWM signals. On the Arduino Nano these are pins 3,5,6,9, 10 and 11.","title":"Glossary of Terms"},{"location":"arduino/glossary/#glossary-of-terms","text":"","title":"Glossary of Terms"},{"location":"arduino/glossary/#arduino","text":"Arduino is the name of a popular open electronic learning platform based around a set of open standards.","title":"Arduino"},{"location":"arduino/glossary/#integrated-development-environment-ide","text":"An integrated development environment (IDE) is a software program used for writing, checking and downloading software into the Arduino.","title":"Integrated Development Environment (IDE)"},{"location":"arduino/glossary/#pulse-wave-modulation-pwm","text":"A way of controlling the speed of a motor or the intensity of a light by changing the amount of time a signal is on. On the Arduino only a subset of output pins can be used to send PWM signals. On the Arduino Nano these are pins 3,5,6,9, 10 and 11.","title":"Pulse Wave Modulation (PWM)"},{"location":"arduino/two-motors/","text":"Two Motors \u00b6 In this lab we will be controlling two motors together to move our robot forward, backward and to turn our robot. The following program has three sections. The first defines the pin numbers and the delay time. The second is the setup() function that sets the pins to be Outputs and then turns the motors off. The last section is the loop() function that will repeat forever. Sample Robot Movement Test \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 int right_forward = 3 ; int right_backward = 5 ; int left_forward = 6 ; int left_backward = 9 ; int delay_time = 1000 ; // 1 second void setup () { pinMode ( right_forward , OUTPUT ); pinMode ( right_backward , OUTPUT ); pinMode ( left_forward , OUTPUT ); pinMode ( left_backward , OUTPUT ); // turn all off digitalWrite ( right_forward , LOW ); digitalWrite ( right_backward , LOW ); digitalWrite ( left_forward , LOW ); digitalWrite ( left_backward , LOW ); } // repeat this function void loop () { // move forward digitalWrite ( right_forward , HIGH ); digitalWrite ( left_forward , HIGH ); delay ( delay_time ); // stop digitalWrite ( right_forward , LOW ); digitalWrite ( left_forward , LOW ); delay ( delay_time ); // reverse digitalWrite ( right_backward , HIGH ); digitalWrite ( left_backward , HIGH ); delay ( delay_time ); // stop digitalWrite ( right_backward , LOW ); digitalWrite ( left_backward , LOW ); delay ( delay_time ); // turn right digitalWrite ( left_forward , HIGH ); digitalWrite ( right_backward , HIGH ); delay ( delay_time ); // stop digitalWrite ( left_forward , LOW ); digitalWrite ( right_backward , LOW ); delay ( delay_time ); // adjust this to change the angle // repeat (go to the top of the loop) } Note that this program does not use the AnalogWrite() functions that use PWM signals. The motors are either completely on or completely off. Also note that the delay_time is 1000ms for each interval. You can change the amount the robot rotates by changing the value of the time in the turn right block of code. A shorter time will turn the robot a smaller angle. Limitations of our Robot \u00b6 You can see that we don't have a fine amount of control our robot rotates. We can only guess the amount the robot turns by setting the timer to different amounts. As the batteries wear down, the amount that the robot turns per unit if time will also change. We will learn more about how to fix this limitation in our advanced labs.","title":"Two Motors"},{"location":"arduino/two-motors/#two-motors","text":"In this lab we will be controlling two motors together to move our robot forward, backward and to turn our robot. The following program has three sections. The first defines the pin numbers and the delay time. The second is the setup() function that sets the pins to be Outputs and then turns the motors off. The last section is the loop() function that will repeat forever.","title":"Two Motors"},{"location":"arduino/two-motors/#sample-robot-movement-test","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 int right_forward = 3 ; int right_backward = 5 ; int left_forward = 6 ; int left_backward = 9 ; int delay_time = 1000 ; // 1 second void setup () { pinMode ( right_forward , OUTPUT ); pinMode ( right_backward , OUTPUT ); pinMode ( left_forward , OUTPUT ); pinMode ( left_backward , OUTPUT ); // turn all off digitalWrite ( right_forward , LOW ); digitalWrite ( right_backward , LOW ); digitalWrite ( left_forward , LOW ); digitalWrite ( left_backward , LOW ); } // repeat this function void loop () { // move forward digitalWrite ( right_forward , HIGH ); digitalWrite ( left_forward , HIGH ); delay ( delay_time ); // stop digitalWrite ( right_forward , LOW ); digitalWrite ( left_forward , LOW ); delay ( delay_time ); // reverse digitalWrite ( right_backward , HIGH ); digitalWrite ( left_backward , HIGH ); delay ( delay_time ); // stop digitalWrite ( right_backward , LOW ); digitalWrite ( left_backward , LOW ); delay ( delay_time ); // turn right digitalWrite ( left_forward , HIGH ); digitalWrite ( right_backward , HIGH ); delay ( delay_time ); // stop digitalWrite ( left_forward , LOW ); digitalWrite ( right_backward , LOW ); delay ( delay_time ); // adjust this to change the angle // repeat (go to the top of the loop) } Note that this program does not use the AnalogWrite() functions that use PWM signals. The motors are either completely on or completely off. Also note that the delay_time is 1000ms for each interval. You can change the amount the robot rotates by changing the value of the time in the turn right block of code. A shorter time will turn the robot a smaller angle.","title":"Sample Robot Movement Test"},{"location":"arduino/two-motors/#limitations-of-our-robot","text":"You can see that we don't have a fine amount of control our robot rotates. We can only guess the amount the robot turns by setting the timer to different amounts. As the batteries wear down, the amount that the robot turns per unit if time will also change. We will learn more about how to fix this limitation in our advanced labs.","title":"Limitations of our Robot"},{"location":"arduino-advanced/advanced-topics/","text":"CoderDojo Arduino Advanced Topics \u00b6 PDI controllers \u00b6 Our base robot may not drive in a straight line. This is because the motors may move slightly differently although they get the same power. The way we can control this is by using servo motors or adding motor position monitoring using Proportional, Derivative, Integral PDI feedback systems. See PDI Controller Servos \u00b6 We could replace our DC motors with servo motors. Although they are much more expensive, we can control the wheel rotation more precisely. Other sensors \u00b6 IR sensors Line following sensors Remote control \u00b6 We can also add a low-cost Bluetooth remote contol system. See the [Arduino Bluetooth Wireless Serial RF Transceiver Module HC-06] (http://www.ebay.com/itm/HC-06-Slave-Bluetooth-Module-Wireless-Serial-Port-Module-Communicate-for-Arduino-/371221433944) Power options \u00b6 More battery power can also be added. Some users find that adding two additional batteries allows the robots more power.","title":"Advanced Topics"},{"location":"arduino-advanced/advanced-topics/#coderdojo-arduino-advanced-topics","text":"","title":"CoderDojo Arduino Advanced Topics"},{"location":"arduino-advanced/advanced-topics/#pdi-controllers","text":"Our base robot may not drive in a straight line. This is because the motors may move slightly differently although they get the same power. The way we can control this is by using servo motors or adding motor position monitoring using Proportional, Derivative, Integral PDI feedback systems. See PDI Controller","title":"PDI controllers"},{"location":"arduino-advanced/advanced-topics/#servos","text":"We could replace our DC motors with servo motors. Although they are much more expensive, we can control the wheel rotation more precisely.","title":"Servos"},{"location":"arduino-advanced/advanced-topics/#other-sensors","text":"IR sensors Line following sensors","title":"Other sensors"},{"location":"arduino-advanced/advanced-topics/#remote-control","text":"We can also add a low-cost Bluetooth remote contol system. See the [Arduino Bluetooth Wireless Serial RF Transceiver Module HC-06] (http://www.ebay.com/itm/HC-06-Slave-Bluetooth-Module-Wireless-Serial-Port-Module-Communicate-for-Arduino-/371221433944)","title":"Remote control"},{"location":"arduino-advanced/advanced-topics/#power-options","text":"More battery power can also be added. Some users find that adding two additional batteries allows the robots more power.","title":"Power options"},{"location":"arduino-advanced/drawing-to-oled/","text":"Drawing to OLED \u00b6 There are two libraries for drawing to small monochrome OLED screens: the Adfruit libraries and the u8g2 libraries. For our robots, which only have 2K or RAM, we will be using the u8g2 libraries because they use only about 1/3 of the RAM when used in the Page Buffer Picture Loop mode. See Page Buffer Picture Loop The u8g2 Monochrome Graphics Library \u00b6 U8g2 Github Site u8g2 Reference Libreary U8g2 Wiki Adafruit \u00b6 Adafruit_SSD1306, which handles the low-level communication with the hardware, and Adafruit_GFX, which builds atop this to add graphics functions like lines, circles and text. We will not be using these libraries because they are too memory intensive. They take over 70% of the available 2K RAM on the Arduino Nano.","title":"Drawing to the OLED"},{"location":"arduino-advanced/drawing-to-oled/#drawing-to-oled","text":"There are two libraries for drawing to small monochrome OLED screens: the Adfruit libraries and the u8g2 libraries. For our robots, which only have 2K or RAM, we will be using the u8g2 libraries because they use only about 1/3 of the RAM when used in the Page Buffer Picture Loop mode. See Page Buffer Picture Loop","title":"Drawing to OLED"},{"location":"arduino-advanced/drawing-to-oled/#the-u8g2-monochrome-graphics-library","text":"U8g2 Github Site u8g2 Reference Libreary U8g2 Wiki","title":"The u8g2 Monochrome Graphics Library"},{"location":"arduino-advanced/drawing-to-oled/#adafruit","text":"Adafruit_SSD1306, which handles the low-level communication with the hardware, and Adafruit_GFX, which builds atop this to add graphics functions like lines, circles and text. We will not be using these libraries because they are too memory intensive. They take over 70% of the available 2K RAM on the Arduino Nano.","title":"Adafruit"},{"location":"arduino-advanced/extending-the-base-robot/","text":"","title":"Extending the Base Robot"},{"location":"arduino-advanced/face-bot/","text":"Adding a OLED Face to Your Robot \u00b6 This version of our robot has an nice high-contrast 128x64 pixel OLED screen on the front of it. We moved the ping sensor below the chasis so that there would be room top front of the robot for the screen. We can draw several things on our screen, including a face with two eyes and a mouth using simple drawing commands. We can also display the parameters on the screen for controlling the collision avoidance robot. For example we can display the distance to the object in front of the robot as measured by the ping sensor. This is a great way to debug our robot. Rather than hooking up the robot up to the USB connection to display the robot status on the Arduino serial console we can display the values \"in the field\" where the robot is running. The 128x64 OLED Screen \u00b6 Although there are many types of small displays that we can use with the Arduino, our favorite is the 2.24\" 128x64 OLED type. We like this screen because it has a bright high-contrast display that is easy to view from all angles and works well under a variety of power conditions. This is in contrast to some LCD screens that are difficult to read in bright light and the contrast changes as the batteries lose power. You can get this display on E-Bay (as of the end of 2018) for around $17.00 (includes shipping) but we hope that the prices come down soon since OLED technology is relatively new. Sample E-Bay OLED Screen This version of the OLED has a standard SSD1309 chip that drives it and by default the display is configured to use the SPI interface. There are a few different versions of the OLED displays, but the ones that are the lowest cost provide for seven SPI connectors: Serial Peripheral Interface Pins: 1.GND (Power Supply Ground) 2.VCC (Power Supply Positive) 3.SCL (Clock Line/SCK to pin 13 on the Nano) 4.SDA (Data Line/MOSI to pin 11 on the Nano) 5.RES (Reset Line) 6.DC (Data/Command) 7.CS (Chip Select) To use the Hardware SPI on the Arduino Nano, we MUST connect the SCL to pin 13 and the SDA to pin 11. See the Documentation tab on the Arduino web site. Note that since the Arduino Nano pin 11 is also a PWM pin we have to run the motors on pins 3, 5, 6 and 9. This chip is supported by several Arduino libraries, which we will talk about next. The u8g2 Monochrome Graphics Library \u00b6 When I first started using these OLED displays I started out using the Adafruit libraries. I ran into a problem with the library using most of my Arduino dynamic memory (about 70% of the 2K available in the Arduino Nano). However, I found another library, the u8g2 Monochrome Graphics Library, that only used about 1/3 of the memory. This library has a Page Buffer Picture Loop mode that only uses a small amount of RAM. U8g2 Github Site U8g2 Wiki Configuring the Right Constructor \u00b6 Getting the right setup for the U8g2 library took some time. There are several setup options that will work. The one I chose is the 4-wire hardware SPI. Hardware interfaces are usually a little bit faster than the software interfaces but they also required a few more connections. Here are the options I selected: SSD1306 (the name of the display driver) 128x64 (the size of our display) NONAME (no specific brand name) 1 page (single 128 byte buffer) 4 wire (as opposed to a 2 wire version) Hardware (as opposed to software) SPI (not the IIC interface) 1 2 // We are using the 128 byte 4W Hardware SPI with no rotation which only uses 27% of dynamic memory U8G2_SSD1306_128X64_NONAME_1_4W_HW_SPI u8g2 ( U8G2_R0 , CS_PIN , DC_PIN , RDS_PIN ); Setup Constructor Reference Selecting The Font \u00b6 The U8g2 library comes with a large number of font to choose from ranging from 4 to 92 pixels high. I tried several sizes of fonts and I found the 8 pixel fonts to be large enough to read even from a looking down at the floor from a standing position. I also selected a variable with Helvetica font that I felt was easy to read. You can read more about the font installation options here Here is the setup function that supports initialization of the display and the font selection: 1 2 3 4 5 6 void setup ( void ) { u8g2 . begin (); // Set font to Helvetica regular 8 pixel font // For other options see https://github.com/olikraus/u8g2/wiki/fntlistall#8-pixel-height u8g2 . setFont ( u8g2_font_helvR08_tf ); } Simple Test of the Display Connections \u00b6 Once we have the right constructor and the font initialization setup we are ready to write our first test program. If this test works, you will know that you have hooked up all seven wires of the display correctly. The following test program just displays \"CoderDojo Rocks\" with a counter that increments so you can see that the display is updating correctly for each loop. Here is the full program for our simple display test: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include <Arduino.h> // For details on the o8g2 library see https://github.com/olikraus/u8g2/wiki #include <U8g2lib.h> #include <SPI.h> // order on OLED - GND, VCC, SCL, SDA, RDS, DC, CS // You can't move these two pins if you use the hardware SPI #define SCL_PIN 13 // SCL clock - 3rd from bottom #define SDA_PIN 11 // SDA, Data, MOSI - must be on pin 11 on the Nano // you can move these pins around as long as you reference the names correctly #define RDS_PIN 10 // reset #define DC_PIN 7 // DC moved from pin 9 which is needed as a PWM pin #define CS_PIN 8 // chip select top // There are many options for initialzation of the display. See https://github.com/olikraus/u8g2/wiki/u8x8setupcpp#constructor-reference // We are using the 128 byte 4W Hardware SPI with no rotation. This uses 27% of the 2K of dynamic memory available on the Arduino Nano U8G2_SSD1306_128X64_NONAME_1_4W_HW_SPI u8g2 ( U8G2_R0 , CS_PIN , DC_PIN , RDS_PIN ); int counter ; // main loop counter to verify the disply is updating. void setup ( void ) { u8g2 . begin (); // Set font to Helvetica regular 8 pixel font // For other options see https://github.com/olikraus/u8g2/wiki/fntlistall#8-pixel-height u8g2 . setFont ( u8g2_font_helvR08_tf ); } void loop ( void ) { u8g2 . firstPage (); do { // x (horiz) is 0 and 7 (vertical) is 8 down for a 8-pixel high font u8g2 . drawStr ( 0 , 8 , \"CoderDojo Rocks!\" ); u8g2 . setCursor ( 0 , 63 ); u8g2 . print ( counter ); } while ( u8g2 . nextPage () ); counter ++ ; // increment the counter by 1 } Testing the Robot Connections \u00b6 Once you have the display working, we can now use the display to verify that the various components are each wired up correctly. You can also do some of this testing using the serial monitor within the Arduino IDE. However, that option requires that your robot be connected via the USB to your computer. The following test are used to test each component, even when the USB is unplugged: .1 Ping Sensor Display Test - this test will display the ping sensor distance on the display. You can use this test to verify that the Trigger and Echo pins are connected correctly. .2 Motor Connection Display Test - this test will cycle through each of the motor controller connections. It will fist run the right forward motor, then the right reverse motor, then the left forward and finally the left reverse. An arrow on the display will show you what wheel should be turning and in what direction. .3 Speaker Display Test - this will display a frequency on the display as it plays on the speaker .4 Rotery Encoder Display Test - this will test the rotary encorder know and the momentary push buttons that are used to change the mode and select an option. Static Integration Display Test \u00b6 Once all the components are individually working you can then run a \"static\" or non-moving components together. This means that all the connections are working but the motor functions are not enabled. Static Integration Display Test Collision Avoidance Robot \u00b6 In this version the robot will move forward until it gets close to an object in front of it. It will then backup a bit and turn either right or left and continue on. OLED Face Ping Bot","title":"Face Bot"},{"location":"arduino-advanced/face-bot/#adding-a-oled-face-to-your-robot","text":"This version of our robot has an nice high-contrast 128x64 pixel OLED screen on the front of it. We moved the ping sensor below the chasis so that there would be room top front of the robot for the screen. We can draw several things on our screen, including a face with two eyes and a mouth using simple drawing commands. We can also display the parameters on the screen for controlling the collision avoidance robot. For example we can display the distance to the object in front of the robot as measured by the ping sensor. This is a great way to debug our robot. Rather than hooking up the robot up to the USB connection to display the robot status on the Arduino serial console we can display the values \"in the field\" where the robot is running.","title":"Adding a OLED Face to Your Robot"},{"location":"arduino-advanced/face-bot/#the-128x64-oled-screen","text":"Although there are many types of small displays that we can use with the Arduino, our favorite is the 2.24\" 128x64 OLED type. We like this screen because it has a bright high-contrast display that is easy to view from all angles and works well under a variety of power conditions. This is in contrast to some LCD screens that are difficult to read in bright light and the contrast changes as the batteries lose power. You can get this display on E-Bay (as of the end of 2018) for around $17.00 (includes shipping) but we hope that the prices come down soon since OLED technology is relatively new. Sample E-Bay OLED Screen This version of the OLED has a standard SSD1309 chip that drives it and by default the display is configured to use the SPI interface. There are a few different versions of the OLED displays, but the ones that are the lowest cost provide for seven SPI connectors: Serial Peripheral Interface Pins: 1.GND (Power Supply Ground) 2.VCC (Power Supply Positive) 3.SCL (Clock Line/SCK to pin 13 on the Nano) 4.SDA (Data Line/MOSI to pin 11 on the Nano) 5.RES (Reset Line) 6.DC (Data/Command) 7.CS (Chip Select) To use the Hardware SPI on the Arduino Nano, we MUST connect the SCL to pin 13 and the SDA to pin 11. See the Documentation tab on the Arduino web site. Note that since the Arduino Nano pin 11 is also a PWM pin we have to run the motors on pins 3, 5, 6 and 9. This chip is supported by several Arduino libraries, which we will talk about next.","title":"The 128x64 OLED Screen"},{"location":"arduino-advanced/face-bot/#the-u8g2-monochrome-graphics-library","text":"When I first started using these OLED displays I started out using the Adafruit libraries. I ran into a problem with the library using most of my Arduino dynamic memory (about 70% of the 2K available in the Arduino Nano). However, I found another library, the u8g2 Monochrome Graphics Library, that only used about 1/3 of the memory. This library has a Page Buffer Picture Loop mode that only uses a small amount of RAM. U8g2 Github Site U8g2 Wiki","title":"The u8g2 Monochrome Graphics Library"},{"location":"arduino-advanced/face-bot/#configuring-the-right-constructor","text":"Getting the right setup for the U8g2 library took some time. There are several setup options that will work. The one I chose is the 4-wire hardware SPI. Hardware interfaces are usually a little bit faster than the software interfaces but they also required a few more connections. Here are the options I selected: SSD1306 (the name of the display driver) 128x64 (the size of our display) NONAME (no specific brand name) 1 page (single 128 byte buffer) 4 wire (as opposed to a 2 wire version) Hardware (as opposed to software) SPI (not the IIC interface) 1 2 // We are using the 128 byte 4W Hardware SPI with no rotation which only uses 27% of dynamic memory U8G2_SSD1306_128X64_NONAME_1_4W_HW_SPI u8g2 ( U8G2_R0 , CS_PIN , DC_PIN , RDS_PIN ); Setup Constructor Reference","title":"Configuring the Right Constructor"},{"location":"arduino-advanced/face-bot/#selecting-the-font","text":"The U8g2 library comes with a large number of font to choose from ranging from 4 to 92 pixels high. I tried several sizes of fonts and I found the 8 pixel fonts to be large enough to read even from a looking down at the floor from a standing position. I also selected a variable with Helvetica font that I felt was easy to read. You can read more about the font installation options here Here is the setup function that supports initialization of the display and the font selection: 1 2 3 4 5 6 void setup ( void ) { u8g2 . begin (); // Set font to Helvetica regular 8 pixel font // For other options see https://github.com/olikraus/u8g2/wiki/fntlistall#8-pixel-height u8g2 . setFont ( u8g2_font_helvR08_tf ); }","title":"Selecting The Font"},{"location":"arduino-advanced/face-bot/#simple-test-of-the-display-connections","text":"Once we have the right constructor and the font initialization setup we are ready to write our first test program. If this test works, you will know that you have hooked up all seven wires of the display correctly. The following test program just displays \"CoderDojo Rocks\" with a counter that increments so you can see that the display is updating correctly for each loop. Here is the full program for our simple display test: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include <Arduino.h> // For details on the o8g2 library see https://github.com/olikraus/u8g2/wiki #include <U8g2lib.h> #include <SPI.h> // order on OLED - GND, VCC, SCL, SDA, RDS, DC, CS // You can't move these two pins if you use the hardware SPI #define SCL_PIN 13 // SCL clock - 3rd from bottom #define SDA_PIN 11 // SDA, Data, MOSI - must be on pin 11 on the Nano // you can move these pins around as long as you reference the names correctly #define RDS_PIN 10 // reset #define DC_PIN 7 // DC moved from pin 9 which is needed as a PWM pin #define CS_PIN 8 // chip select top // There are many options for initialzation of the display. See https://github.com/olikraus/u8g2/wiki/u8x8setupcpp#constructor-reference // We are using the 128 byte 4W Hardware SPI with no rotation. This uses 27% of the 2K of dynamic memory available on the Arduino Nano U8G2_SSD1306_128X64_NONAME_1_4W_HW_SPI u8g2 ( U8G2_R0 , CS_PIN , DC_PIN , RDS_PIN ); int counter ; // main loop counter to verify the disply is updating. void setup ( void ) { u8g2 . begin (); // Set font to Helvetica regular 8 pixel font // For other options see https://github.com/olikraus/u8g2/wiki/fntlistall#8-pixel-height u8g2 . setFont ( u8g2_font_helvR08_tf ); } void loop ( void ) { u8g2 . firstPage (); do { // x (horiz) is 0 and 7 (vertical) is 8 down for a 8-pixel high font u8g2 . drawStr ( 0 , 8 , \"CoderDojo Rocks!\" ); u8g2 . setCursor ( 0 , 63 ); u8g2 . print ( counter ); } while ( u8g2 . nextPage () ); counter ++ ; // increment the counter by 1 }","title":"Simple Test of the Display Connections"},{"location":"arduino-advanced/face-bot/#testing-the-robot-connections","text":"Once you have the display working, we can now use the display to verify that the various components are each wired up correctly. You can also do some of this testing using the serial monitor within the Arduino IDE. However, that option requires that your robot be connected via the USB to your computer. The following test are used to test each component, even when the USB is unplugged: .1 Ping Sensor Display Test - this test will display the ping sensor distance on the display. You can use this test to verify that the Trigger and Echo pins are connected correctly. .2 Motor Connection Display Test - this test will cycle through each of the motor controller connections. It will fist run the right forward motor, then the right reverse motor, then the left forward and finally the left reverse. An arrow on the display will show you what wheel should be turning and in what direction. .3 Speaker Display Test - this will display a frequency on the display as it plays on the speaker .4 Rotery Encoder Display Test - this will test the rotary encorder know and the momentary push buttons that are used to change the mode and select an option.","title":"Testing the Robot Connections"},{"location":"arduino-advanced/face-bot/#static-integration-display-test","text":"Once all the components are individually working you can then run a \"static\" or non-moving components together. This means that all the connections are working but the motor functions are not enabled. Static Integration Display Test","title":"Static Integration Display Test"},{"location":"arduino-advanced/face-bot/#collision-avoidance-robot","text":"In this version the robot will move forward until it gets close to an object in front of it. It will then backup a bit and turn either right or left and continue on. OLED Face Ping Bot","title":"Collision Avoidance Robot"},{"location":"mbot/00-intro/","text":"Introduction to mBot \u00b6 In these lessions plans we will learn some basic principals of computer science using the mBot robot. These lessons are ideal for students that have not mastered keyboarding skills but still would like to program their own robot. Order of Labs \u00b6 We start out with Desktop labs that don't use the motors. This is because motors drain the batteries and if the students are not careful the mBot will fall off the desks and break. It is only AFTER our students master the initial skills that we enable the motor labs which are done while the mBot is on the floor. We strongly discorage motor labs when the mBot is not on the floor. Desktop Labs \u00b6 Our first labs will verify that the mBot is hooked up correctly and that our students can change the color of the LED on top of the mBot. We then will introduce the repeat block to make the LEDs flash on and off or change colors. Next we will experiment with the ping sensor to measure the distance between the robot and an object in front of the robot. We will use this to change the LED colors, the blink rate or the color of the LEDs. After the students have mastered running programs, changing the LEDs and using the ping sensor we will move on to controlling the motors. Motor Labs (only done when the mBot is on the Floor) \u00b6 We have several simple labs we start out with. The first labs are a simple motion and turning labs. Once the students can make the robot go in a square, a circle or dance using random number generation we move on to integrating the ping sensor. The ping sensor is then used to turn the robot when an object is in front of the robot. We then make the robot reverse and turn in a random direction when it sees an object in front of the robot. mBot Video tutorials \u00b6","title":"00 intro"},{"location":"mbot/00-intro/#introduction-to-mbot","text":"In these lessions plans we will learn some basic principals of computer science using the mBot robot. These lessons are ideal for students that have not mastered keyboarding skills but still would like to program their own robot.","title":"Introduction to mBot"},{"location":"mbot/00-intro/#order-of-labs","text":"We start out with Desktop labs that don't use the motors. This is because motors drain the batteries and if the students are not careful the mBot will fall off the desks and break. It is only AFTER our students master the initial skills that we enable the motor labs which are done while the mBot is on the floor. We strongly discorage motor labs when the mBot is not on the floor.","title":"Order of Labs"},{"location":"mbot/00-intro/#desktop-labs","text":"Our first labs will verify that the mBot is hooked up correctly and that our students can change the color of the LED on top of the mBot. We then will introduce the repeat block to make the LEDs flash on and off or change colors. Next we will experiment with the ping sensor to measure the distance between the robot and an object in front of the robot. We will use this to change the LED colors, the blink rate or the color of the LEDs. After the students have mastered running programs, changing the LEDs and using the ping sensor we will move on to controlling the motors.","title":"Desktop Labs"},{"location":"mbot/00-intro/#motor-labs-only-done-when-the-mbot-is-on-the-floor","text":"We have several simple labs we start out with. The first labs are a simple motion and turning labs. Once the students can make the robot go in a square, a circle or dance using random number generation we move on to integrating the ping sensor. The ping sensor is then used to turn the robot when an object is in front of the robot. We then make the robot reverse and turn in a random direction when it sees an object in front of the robot.","title":"Motor Labs (only done when the mBot is on the Floor)"},{"location":"mbot/00-intro/#mbot-video-tutorials","text":"","title":"mBot Video tutorials"},{"location":"mbot/01-set-led-color/","text":"Set LED Color \u00b6 Our first program will set the color of the LEDs on top of the mBot to red. Steps \u00b6 Make sure your dongle is plugged into the computer Start the mBlock program on the PC Click the \"Connect\" menu and check that you have a green dot on the mBlock area Sample program \u00b6","title":"Set LED Color"},{"location":"mbot/01-set-led-color/#set-led-color","text":"Our first program will set the color of the LEDs on top of the mBot to red.","title":"Set LED Color"},{"location":"mbot/01-set-led-color/#steps","text":"Make sure your dongle is plugged into the computer Start the mBlock program on the PC Click the \"Connect\" menu and check that you have a green dot on the mBlock area","title":"Steps"},{"location":"mbot/01-set-led-color/#sample-program","text":"","title":"Sample program"},{"location":"mbot/02-blink/","text":"Blink LED \u00b6 Steps \u00b6 In the example below, the quotes are around the block name and the block parameters are in bold. Drag the \"When space Key Pressed\" block onto the screen. Drag the forever control onto the screen. Add the \"Set LED on board all red 255 \" in the forever block Drag the Wait 1 second block under that Add the \"Set LED on board all red 0 \" in the forever block Add a second wait 1 second block under that Sample Program \u00b6 Sample GIF Image \u00b6 Blink example on Mblock site \u00b6 https://www.mblock.cc/example/blink/","title":"Blink LED"},{"location":"mbot/02-blink/#blink-led","text":"","title":"Blink LED"},{"location":"mbot/02-blink/#steps","text":"In the example below, the quotes are around the block name and the block parameters are in bold. Drag the \"When space Key Pressed\" block onto the screen. Drag the forever control onto the screen. Add the \"Set LED on board all red 255 \" in the forever block Drag the Wait 1 second block under that Add the \"Set LED on board all red 0 \" in the forever block Add a second wait 1 second block under that","title":"Steps"},{"location":"mbot/02-blink/#sample-program","text":"","title":"Sample Program"},{"location":"mbot/02-blink/#sample-gif-image","text":"","title":"Sample GIF Image"},{"location":"mbot/02-blink/#blink-example-on-mblock-site","text":"https://www.mblock.cc/example/blink/","title":"Blink example on Mblock site"},{"location":"mbot/03-alternate-blink/","text":"Alternate Blink LED \u00b6 In this lab we will make both the LEDs on top of the robot blink red, then green, then blue. Each color will display for 1/2 second. Steps \u00b6 First, drag the \"When space Key Pressed\" block onto the screen. Next, drag the \"Forever\" block under that block. Next, \"Set LED on board all red 255 \" Under that add a \"Wait .5 second\" block Next, \"Set LED on board \"all\" green 255\" Under that add a \"Wait .5 second\" block Next, \"Set LED on board \"all\" blue 255\" Under that add a \"Wait .5 second\" block Now press the \"Space\" bar on the keyboard. The block should briefly flash with a yellow border so you know that the block event has been triggered. Sample Block Diagram \u00b6 Experiments \u00b6 Can you make the left and right lights alternate? What happens when you change the \"Set LED on board\" from \"All\" to be \"Right\" or \"Left\".","title":"Alternate Blink"},{"location":"mbot/03-alternate-blink/#alternate-blink-led","text":"In this lab we will make both the LEDs on top of the robot blink red, then green, then blue. Each color will display for 1/2 second.","title":"Alternate Blink LED"},{"location":"mbot/03-alternate-blink/#steps","text":"First, drag the \"When space Key Pressed\" block onto the screen. Next, drag the \"Forever\" block under that block. Next, \"Set LED on board all red 255 \" Under that add a \"Wait .5 second\" block Next, \"Set LED on board \"all\" green 255\" Under that add a \"Wait .5 second\" block Next, \"Set LED on board \"all\" blue 255\" Under that add a \"Wait .5 second\" block Now press the \"Space\" bar on the keyboard. The block should briefly flash with a yellow border so you know that the block event has been triggered.","title":"Steps"},{"location":"mbot/03-alternate-blink/#sample-block-diagram","text":"","title":"Sample Block Diagram"},{"location":"mbot/03-alternate-blink/#experiments","text":"Can you make the left and right lights alternate? What happens when you change the \"Set LED on board\" from \"All\" to be \"Right\" or \"Left\".","title":"Experiments"},{"location":"mbot/04-ping-color/","text":"Conditional Ping \u00b6","title":"Ping Color"},{"location":"mbot/04-ping-color/#conditional-ping","text":"","title":"Conditional Ping"},{"location":"mbot/04-random-color/","text":"Random Color \u00b6 In this lab, our goal is to create a program that generates random colors on the LEDs. https://www.mblock.cc/example/random-color/","title":"Random Color"},{"location":"mbot/04-random-color/#random-color","text":"In this lab, our goal is to create a program that generates random colors on the LEDs. https://www.mblock.cc/example/random-color/","title":"Random Color"},{"location":"mbot/05-green-to-go/","text":"Green Means Go \u00b6 This program will make both LEDs turn green if there is nothing in front of the ping sensor. To do this we will need to place the if then block inside of the forever block. The condition will be the if ultrasonic sensor less than 15. Sample Block Program \u00b6 Experiments \u00b6 Can you change the LEDs to be different colors? Can you change the left and right LED color separately?","title":"Green Means Go"},{"location":"mbot/05-green-to-go/#green-means-go","text":"This program will make both LEDs turn green if there is nothing in front of the ping sensor. To do this we will need to place the if then block inside of the forever block. The condition will be the if ultrasonic sensor less than 15.","title":"Green Means Go"},{"location":"mbot/05-green-to-go/#sample-block-program","text":"","title":"Sample Block Program"},{"location":"mbot/05-green-to-go/#experiments","text":"Can you change the LEDs to be different colors? Can you change the left and right LED color separately?","title":"Experiments"},{"location":"mbot/06-rainbow-colors/","text":"Rainbow Colors \u00b6","title":"Rainbow Colors"},{"location":"mbot/06-rainbow-colors/#rainbow-colors","text":"","title":"Rainbow Colors"},{"location":"mbot/07-drive-square/","text":"Drive Square \u00b6 In this lab we want to make our robot drive in a square each time the letter \"g\" (for go) is pressed on the keyboard. To do this we will use a repeat 4 block since there are four sides in a square. For each side we will drive forward for 1 second and then turn right about .7 seconds. This will drive in the shape of a square. We can stop the robot by pressing the space bar. Sample Block Program \u00b6 mBlock links \u00b6 Drive Square Video","title":"Drive Square"},{"location":"mbot/07-drive-square/#drive-square","text":"In this lab we want to make our robot drive in a square each time the letter \"g\" (for go) is pressed on the keyboard. To do this we will use a repeat 4 block since there are four sides in a square. For each side we will drive forward for 1 second and then turn right about .7 seconds. This will drive in the shape of a square. We can stop the robot by pressing the space bar.","title":"Drive Square"},{"location":"mbot/07-drive-square/#sample-block-program","text":"","title":"Sample Block Program"},{"location":"mbot/07-drive-square/#mblock-links","text":"Drive Square Video","title":"mBlock links"},{"location":"mbot/08-collision-avoidance/","text":"Collision Avoidance \u00b6 In the world of teaching robotics, the equivalent of \"Hello World!\" is the collision avoidance program. The idea is to put your robot on the floor with a set of objects that it must drive around. The robot must be going forward if there are no objects in front of it. But if an object is in front of it, it will need to turn and drive in another direction. Demo Mode 2 (Green LED) Demo \u00b6 For our mBot, the collision avoidance algorithm can be turned by using Mode 2 where the top LED lights turn green after pressing the mode switch from the default white mode. But we want to be able to program our own collision avoidance mode. The algorithm \u00b6 Block Diagram \u00b6 mBot Links and Video \u00b6 mBlock example site Collision Avoidance Video on YouTube Jack Dahms Video: Obstacle Detection and Avoidance","title":"Collision Avoidance"},{"location":"mbot/08-collision-avoidance/#collision-avoidance","text":"In the world of teaching robotics, the equivalent of \"Hello World!\" is the collision avoidance program. The idea is to put your robot on the floor with a set of objects that it must drive around. The robot must be going forward if there are no objects in front of it. But if an object is in front of it, it will need to turn and drive in another direction.","title":"Collision Avoidance"},{"location":"mbot/08-collision-avoidance/#demo-mode-2-green-led-demo","text":"For our mBot, the collision avoidance algorithm can be turned by using Mode 2 where the top LED lights turn green after pressing the mode switch from the default white mode. But we want to be able to program our own collision avoidance mode.","title":"Demo Mode 2 (Green LED) Demo"},{"location":"mbot/08-collision-avoidance/#the-algorithm","text":"","title":"The algorithm"},{"location":"mbot/08-collision-avoidance/#block-diagram","text":"","title":"Block Diagram"},{"location":"mbot/08-collision-avoidance/#mbot-links-and-video","text":"mBlock example site Collision Avoidance Video on YouTube Jack Dahms Video: Obstacle Detection and Avoidance","title":"mBot Links and Video"},{"location":"mbot/08-dance/","text":"Dance \u00b6","title":"Dance"},{"location":"mbot/08-dance/#dance","text":"","title":"Dance"},{"location":"mbot/09-collision-avoidance-random/","text":"Collision Avoidance \u00b6 When we get too close to an object we turn right to avoid it.","title":"Collision Avoidance Random"},{"location":"mbot/09-collision-avoidance-random/#collision-avoidance","text":"When we get too close to an object we turn right to avoid it.","title":"Collision Avoidance"},{"location":"mbot/10-collision-avoidance-reverse/","text":"Collision Avoidance Reverse \u00b6 Take the collision avoidance lab and when it senses and object in front of it, make it drive in reverse for a second before it randomly turns.","title":"Collision Avoidance Reverse"},{"location":"mbot/10-collision-avoidance-reverse/#collision-avoidance-reverse","text":"Take the collision avoidance lab and when it senses and object in front of it, make it drive in reverse for a second before it randomly turns.","title":"Collision Avoidance Reverse"},{"location":"mbot/10-line-follower/","text":"Line Follower \u00b6 This is the third demo program (blue LED lights). When you turn the mBot on, press the mode button twice. Then place the mBot on the figure 8 track. Sample Block Programs \u00b6 Change LED From Sensor \u00b6 Line Follower Full \u00b6","title":"Line Follower"},{"location":"mbot/10-line-follower/#line-follower","text":"This is the third demo program (blue LED lights). When you turn the mBot on, press the mode button twice. Then place the mBot on the figure 8 track.","title":"Line Follower"},{"location":"mbot/10-line-follower/#sample-block-programs","text":"","title":"Sample Block Programs"},{"location":"mbot/10-line-follower/#change-led-from-sensor","text":"","title":"Change LED From Sensor"},{"location":"mbot/10-line-follower/#line-follower-full","text":"","title":"Line Follower Full"},{"location":"mbot/11-collision-avoidance-led-status/","text":"Collision Avoidance LED Status \u00b6 Take the collision avoidance lab and when it senses and object in front of it, make it drive in reverse for a second before it randomly turns. Update the LED colors to show the state of the car: Green - driving forward with nothing in front of the robot. Red - Sense an object in front of the robot Yellow - Driving in reverse Purple - randomly turning","title":"Collision Avoidance LED Status"},{"location":"mbot/11-collision-avoidance-led-status/#collision-avoidance-led-status","text":"Take the collision avoidance lab and when it senses and object in front of it, make it drive in reverse for a second before it randomly turns. Update the LED colors to show the state of the car: Green - driving forward with nothing in front of the robot. Red - Sense an object in front of the robot Yellow - Driving in reverse Purple - randomly turning","title":"Collision Avoidance LED Status"},{"location":"mbot/12-cliff-detection/","text":"Cliff Detection \u00b6 In this lab, our goal is to create a program that keeps the robot from driving off the end of a table.","title":"Cliff Detection"},{"location":"mbot/12-cliff-detection/#cliff-detection","text":"In this lab, our goal is to create a program that keeps the robot from driving off the end of a table.","title":"Cliff Detection"},{"location":"mbot/introduction/","text":"Introduction to mBot \u00b6 In these lessions plans we will learn some basic principals of computer science using the mBot robot. These lessons are ideal for students that have not mastered keyboarding skills but still would like to program their own robot. Order of Labs \u00b6 We start out with Desktop labs that don't use the motors. This is because motors drain the batteries and if the students are not careful the mBot will fall off the desks and break. It is only AFTER our students master the initial skills that we enable the motor labs which are done while the mBot is on the floor. We strongly discorage motor labs when the mBot is not on the floor. Desktop Labs \u00b6 Our first labs will verify that the mBot is hooked up correctly and that our students can change the color of the LED on top of the mBot. We then will introduce the repeat block to make the LEDs flash on and off or change colors. Next we will experiment with the ping sensor to measure the distance between the robot and an object in front of the robot. We will use this to change the LED colors, the blink rate or the color of the LEDs. After the students have mastered running programs, changing the LEDs and using the ping sensor we will move on to controlling the motors. Motor Labs (only done when the mBot is on the Floor) \u00b6 We have several simple labs we start out with. The first labs are a simple motion and turning labs. Once the students can make the robot go in a square, a circle or dance using random number generation we move on to integrating the ping sensor. The ping sensor is then used to turn the robot when an object is in front of the robot. We then make the robot reverse and turn in a random direction when it sees an object in front of the robot.","title":"Introduction"},{"location":"mbot/introduction/#introduction-to-mbot","text":"In these lessions plans we will learn some basic principals of computer science using the mBot robot. These lessons are ideal for students that have not mastered keyboarding skills but still would like to program their own robot.","title":"Introduction to mBot"},{"location":"mbot/introduction/#order-of-labs","text":"We start out with Desktop labs that don't use the motors. This is because motors drain the batteries and if the students are not careful the mBot will fall off the desks and break. It is only AFTER our students master the initial skills that we enable the motor labs which are done while the mBot is on the floor. We strongly discorage motor labs when the mBot is not on the floor.","title":"Order of Labs"},{"location":"mbot/introduction/#desktop-labs","text":"Our first labs will verify that the mBot is hooked up correctly and that our students can change the color of the LED on top of the mBot. We then will introduce the repeat block to make the LEDs flash on and off or change colors. Next we will experiment with the ping sensor to measure the distance between the robot and an object in front of the robot. We will use this to change the LED colors, the blink rate or the color of the LEDs. After the students have mastered running programs, changing the LEDs and using the ping sensor we will move on to controlling the motors.","title":"Desktop Labs"},{"location":"mbot/introduction/#motor-labs-only-done-when-the-mbot-is-on-the-floor","text":"We have several simple labs we start out with. The first labs are a simple motion and turning labs. Once the students can make the robot go in a square, a circle or dance using random number generation we move on to integrating the ping sensor. The ping sensor is then used to turn the robot when an object is in front of the robot. We then make the robot reverse and turn in a random direction when it sees an object in front of the robot.","title":"Motor Labs (only done when the mBot is on the Floor)"},{"location":"mbot/mbot-instructors-guides/","text":"mBot Instructor's Guide \u00b6 Try not to drop the robots or step on them Warn the students that it is easy to drive off the tables All labs that use the motors should be done on the floor Avoid remote control lab early in the learning session. Kids just drive around and, although they have fun, they don't learn much computer science. Keep them as a fun reward if they reach a stretch goal. There are several concepts that we want to teach in these labs: Block Programming - this is just like Scratch programming but there are additional block for controlling the robot. Events - each key press on the keyboard can be different events and they can run different programs Loops - the forever and repeat blocks Conditionals - the if then block is ideal for checking the ping sensor Reading sensors - We used the ultrasonic sensor on the front of the mBot as a way to read sensor values. Functions - We can create abstractions for \"drive in a circle\" and \"drive in a square\" by putting them in new blocks. The mBot Default Programs \u00b6 When you first turn on the mBot they are in one of three \"demo\" programs: Remote control (White) - use the forward, back, left and right buttons on the remote and change the speed with the number_modes Collision avoidance (Green) line following - Note: no PC is needed for these modes. Just the mBots and batteries! Each box has a figure 8 course. If we have a white table-top you can put down black tape Connecting mobile devices to your PC \u00b6 We use the 2.4GHz dongle and the green circle must be on the mBot blocks after you run the Connect/2.4Ghz menu. Some teaching strategies \u00b6 try to keep the initial labs simple introduce one simple concept at a time constantly ask the students for their own ideas of what they want to change. Younger kids want to change colors. Repetition helps them learn and remember. try to keep the robots on the desk using the LED labs to start. Keep the motor labs for later in the session Avoid the sound labs if the room is too noisy Here are some \"mBot\" challenges: \u00b6 Not all students want to follow step-by-step instructions. For these students, just give them a list of challenges and see if they can figure them out the programs themselves. Make the LED on the top of the mBot turn red when you hit the spacebar and off when you hit the \"o\" key Make the LED blink continuously using the forever loop - change the speed of the blinking Make the color change when you move your hand closer to the mbot Bind the forward, back, left and right to the arrow keys Make the robot drive a single square Make the robot dance - pick a random direction to turn and a random distance to move Make the robot go forward unless there is an object in front. Then turn. (Collision avoidance)","title":"Instructor's Guide"},{"location":"mbot/mbot-instructors-guides/#mbot-instructors-guide","text":"Try not to drop the robots or step on them Warn the students that it is easy to drive off the tables All labs that use the motors should be done on the floor Avoid remote control lab early in the learning session. Kids just drive around and, although they have fun, they don't learn much computer science. Keep them as a fun reward if they reach a stretch goal. There are several concepts that we want to teach in these labs: Block Programming - this is just like Scratch programming but there are additional block for controlling the robot. Events - each key press on the keyboard can be different events and they can run different programs Loops - the forever and repeat blocks Conditionals - the if then block is ideal for checking the ping sensor Reading sensors - We used the ultrasonic sensor on the front of the mBot as a way to read sensor values. Functions - We can create abstractions for \"drive in a circle\" and \"drive in a square\" by putting them in new blocks.","title":"mBot Instructor's Guide"},{"location":"mbot/mbot-instructors-guides/#the-mbot-default-programs","text":"When you first turn on the mBot they are in one of three \"demo\" programs: Remote control (White) - use the forward, back, left and right buttons on the remote and change the speed with the number_modes Collision avoidance (Green) line following - Note: no PC is needed for these modes. Just the mBots and batteries! Each box has a figure 8 course. If we have a white table-top you can put down black tape","title":"The mBot Default Programs"},{"location":"mbot/mbot-instructors-guides/#connecting-mobile-devices-to-your-pc","text":"We use the 2.4GHz dongle and the green circle must be on the mBot blocks after you run the Connect/2.4Ghz menu.","title":"Connecting mobile devices to your PC"},{"location":"mbot/mbot-instructors-guides/#some-teaching-strategies","text":"try to keep the initial labs simple introduce one simple concept at a time constantly ask the students for their own ideas of what they want to change. Younger kids want to change colors. Repetition helps them learn and remember. try to keep the robots on the desk using the LED labs to start. Keep the motor labs for later in the session Avoid the sound labs if the room is too noisy","title":"Some teaching strategies"},{"location":"mbot/mbot-instructors-guides/#here-are-some-mbot-challenges","text":"Not all students want to follow step-by-step instructions. For these students, just give them a list of challenges and see if they can figure them out the programs themselves. Make the LED on the top of the mBot turn red when you hit the spacebar and off when you hit the \"o\" key Make the LED blink continuously using the forever loop - change the speed of the blinking Make the color change when you move your hand closer to the mbot Bind the forward, back, left and right to the arrow keys Make the robot drive a single square Make the robot dance - pick a random direction to turn and a random distance to move Make the robot go forward unless there is an object in front. Then turn. (Collision avoidance)","title":"Here are some \"mBot\" challenges:"},{"location":"mbot/programming-with-scratch/","text":"Programming with Scratch \u00b6 You can also use the mblock http://www.mblock.cc system to program your robot using the MIT scratch programming language. To do this use the following steps: download the mblock application on your Windows or Mac other instructions by Rick...","title":"Programming with Scratch"},{"location":"mbot/programming-with-scratch/#programming-with-scratch","text":"You can also use the mblock http://www.mblock.cc system to program your robot using the MIT scratch programming language. To do this use the following steps: download the mblock application on your Windows or Mac other instructions by Rick...","title":"Programming with Scratch"}]}